#!/bin/zsh

function D() {
    print -u2 ${FG[white]}$*
}

function @z() {
    local _source
    local -a estack
    

    integer lc=0 

    function dump() {
        for x in $estack; do
            D " --: " + $x
        done
    }

    function @e() {
        local sh
        sh="$(<&0)"
        eval "$sh"
    }

    function @() {
        (
            local sh
            sh="$(<&0)"
            [[ -z $sh ]] && return
            print "${(e)sh}"
        )
    }

    function @if() {
        eval "$*" && {
            skip=
            @
        } || {
            skip=true
        }
        # echo "      $* -> $skip"
    }

    skip=
    
    function zeval() {
        [[ -n $estack ]] && {
            <<< ${(F)estack[2,-1]} | eval "$estack[1]"
            estack=()
        }
    }

    [[ -n $1 ]] && {
        _source="$(<$1)"
    } || {
        _source="$(<&0)"
    }
    
    NEXT_MATCH='(^#-{4,120}\|)(\s*)(.*$)'
    estack=(@)
    for line in "${(@f)_source}"; do
        (( lc++ ))

        # instruction
        if [[ $line =~ '(^#-{4,120}\|)(\s*)(\[\[.*\]\])' ]]; then
            # echo "   $match[3]"
            eval "$match[3]" && {
                skip=
            } || {
                skip=true
            }
        elif [[ $line =~ $NEXT_MATCH ]] && [[ -z $skip ]]; then
            zeval
            estack=(${match[3]:=@})
            continue
        fi
        
        [[ $skip == true ]] && continue

        [[ -n $estack ]] && {  
            estack+=$line
        } || {
            estack=(@)
        }
    done
    zeval
}

@z $*
